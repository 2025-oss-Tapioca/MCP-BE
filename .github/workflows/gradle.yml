# .github/workflows/deploy.yml
name: "ðŸš€ Spring Boot Docker CI/CD (no compose)"

on:
  push:
    branches: ["dev"]

concurrency:
  group: ci-${{ github.ref }}
  cancel-in-progress: true

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    timeout-minutes: 45

    env:
      IMAGE_NAME: ${{ secrets.DOCKER_USERNAME }}/docker-test
      APP_PORT: "8080" # ì»¨í…Œì´ë„ˆ ë‚´ë¶€/ì™¸ë¶€ í¬íŠ¸ (Spring ê¸°ë³¸ 8080)

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: "17"
          distribution: "temurin"
          cache: "gradle"

      # ì‹œí¬ë¦¿ì— APPLICATION_YML(ì›ë¬¸) ë„£ì€ ê²½ìš°ì—ë§Œ íŒŒì¼ ìƒì„±
      - name: Create application.yml from Secrets (optional)
        env:
          APPLICATION_YML: ${{ secrets.APPLICATION_YML }}
        run: |
          mkdir -p ./src/main/resources
          if [ -n "${APPLICATION_YML:-}" ]; then
            printf '%s' "$APPLICATION_YML" > ./src/main/resources/application.yml
            echo "application.yml created from secret."
          else
            echo "APPLICATION_YML is empty. Skipping."
          fi

      - name: Grant execute permission for gradlew
        run: chmod +x ./gradlew

      - name: Build with Gradle (skip tests)
        run: ./gradlew clean build -x test

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Build and push Docker image
        run: |
          set -euo pipefail
          IMAGE_SHA="${IMAGE_NAME}:${{ github.sha }}"
          IMAGE_BRANCH="${IMAGE_NAME}:${{ github.ref_name }}"
          echo "Building $IMAGE_SHA and $IMAGE_BRANCH"
          docker build -t "$IMAGE_SHA" -t "$IMAGE_BRANCH" .
          docker push "$IMAGE_SHA"
          docker push "$IMAGE_BRANCH"
          echo "image_sha=$IMAGE_SHA" >> $GITHUB_OUTPUT
          echo "image_branch=$IMAGE_BRANCH" >> $GITHUB_OUTPUT

      - name: Remote deploy to EC2 (no compose)
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.HOST }}
          port: ${{ secrets.PORT }}
          username: ubuntu
          key: ${{ secrets.PRIVATE_KEY }}
          script: |
            set -euo pipefail

            IMAGE="${{ secrets.DOCKER_USERNAME }}/docker-test:${{ github.sha }}"
            CONTAINER_NAME="web"
            APP_PORT="${{ env.APP_PORT }}"

            echo "[INFO] Using image: $IMAGE"

            # 0) ê¸°ë³¸ íŒ¨í‚¤ì§€ ì—…ë°ì´íŠ¸ (ì¡°ìš©ížˆ)
            sudo apt-get update -y -qq || true

            # 1) docker ì„¤ì¹˜ ì—¬ë¶€ í™•ì¸ & ì„¤ì¹˜ (Ubuntu)
            if ! command -v docker >/dev/null 2>&1; then
              echo "[INFO] Docker not found. Installing..."
              sudo apt-get install -y -qq ca-certificates curl gnupg lsb-release
              sudo install -m 0755 -d /etc/apt/keyrings
              curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
              echo \
                "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \
                $(. /etc/os-release && echo "$VERSION_CODENAME") stable" | \
                sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
              sudo apt-get update -y -qq
              sudo apt-get install -y -qq docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
            fi

            # 2) docker ë°ëª¬ ê¸°ë™/ë³µêµ¬
            echo "[INFO] (Re)starting docker service..."
            sudo systemctl daemon-reload || true
            sudo systemctl enable --now docker || true

            # ë¹ ë¥¸ ë³µêµ¬ ë£¨í‹´ (stale pid, containerd ì´ìŠˆ ë“±)
            if ! sudo docker info >/dev/null 2>&1; then
              echo "[WARN] docker not responding; applying quick fixes..."
              sudo rm -f /var/run/docker.pid || true
              sudo systemctl restart containerd || true
              sudo systemctl restart docker
              sleep 3
            fi

            # ìµœì¢… í™•ì¸ (ì‹¤íŒ¨ ì‹œ ë¡œê·¸ ë¤í”„ í›„ ì¢…ë£Œ)
            if ! sudo docker info >/dev/null 2>&1; then
              echo "[ERROR] Docker daemon still down. Showing logs..."
              sudo journalctl -u docker -n 200 --no-pager || true
              sudo journalctl -u containerd -n 200 --no-pager || true
              exit 1
            fi

            # 3) ì´ë¯¸ì§€ pull & ì»¨í…Œì´ë„ˆ ìž¬ê¸°ë™
            echo "[INFO] Pulling image..."
            sudo docker pull "$IMAGE"

            echo "[INFO] Stopping old container (if exists)..."
            sudo docker stop "$CONTAINER_NAME" || true
            sudo docker rm "$CONTAINER_NAME" || true

            echo "[INFO] Running new container..."
            sudo docker run -d --name "$CONTAINER_NAME" \
              -p ${APP_PORT}:${APP_PORT} \
              --restart unless-stopped \
              -e SERVER_PORT=${APP_PORT} \
              "$IMAGE"

            # 4) ìš©ëŸ‰ ì •ë¦¬
            sudo docker image prune -f || true

            # 5) (ì˜µì…˜) í—¬ìŠ¤ì²´í¬: ë£¨íŠ¸ ê²½ë¡œë¡œ ê°„ë‹¨ í™•ì¸ (Actuator ì—†ë‹¤ë©´ 200ì´ ì•„ë‹ˆì–´ë„ ë¬´ì‹œ)
            echo "[INFO] Health check (best-effort)..."
            for i in $(seq 1 15); do
              if curl -fsS "http://127.0.0.1:${APP_PORT}/" >/dev/null 2>&1; then
                echo "[INFO] App responded on port ${APP_PORT}"
                break
              fi
              echo "[INFO] waiting app... ($i/15)"
              sleep 2
            done
